#JS

---
### 동기 vs 비동기 프로그래밍
JS는 둘다 가능

동기 프로그래밍 : 순차적으로 프로세스 진행, 더 오래 걸림, 완료 지점이 있음
비동기 프로그래밍 : 병행성을 가짐, 시간 단축 가능, 완료 지점 판단 어려움
-> (작업 완료 여부를 따로 확인하지 않음)
- 병행성 : 단일 스레드 내에서 비동기 작업을 처리하는 동안 다른 작업을 중단하지 않고 계속 진행할 수 있음
- 비동기 작업 : 동시에 시작하는 것이 아닌, 작업을 하는 동안 또다른 작업을 진행하는 것

왜 비동기 안써?
: 많이 쓰면 코드 가독성이 좀 떨어지고.. 복잡해진다.


### Callback 함수
비동기 프로그래밍에서 작업이 끝났음을 개발자에게 알려주는 함수 라고 보면 된다
대표적인 콜백 함수 - setTimeOut(함수, ms)
-> ms초 뒤에 함수 실행

 ***= 알림을 준다***

```
function orderFood(food, callback){
	console.log(`${food} 주문을 시작해요.`);
	setTimeout(function(){
		console.log(`${food}가 배달되었습니다.);
		callback();
	}, 3000);
}

orderFood('피자', function(){
	console.log("맛있게 드세요 !");
})
```
주문 시작 -> 3초 후 배달 완료, 맛있게 드세요 확인


### Promise
비동기 프로그래밍에서 작업의 성공 실패에 대한 분기 처리
(성공하면 -> ... , 실패하면 -> ...)
resolve : 성공, reject : 실패

 ***= 성공/실패를 판별, 분기***

```
const orderFood = new Promise((resolve, reject => {
	const isDelivered = true;
	if (isDelivered == true) {
		resolve("음식이 배달되었습니다.");
	} else {
		reject(배달이 실패하였습니다.);
	}
}))

orderFood.then((message) => {
	console.log(message);
	console.log("맛있게 드셈);
	}).catch((error) => {
	console.log(error)
})
```


### Async, Await
비동기 프로그래밍에서 작업에 대한 응답을 받고, 이후 작업을 실행할 때까지 대기하는 구조를 구현
async function(~) ... await function2(~) ...
-> async를 부여한 함수가 작업 결과를 돌려받으면 await이 달린 함수를 실행

 ***= 기다렸다가 받는다***
 

```
async function orderAndEat(){
	console.log("음식을 주문했어요!");
	const message = await deliverFood();
	console.log(message);
	console.log("이제 음식을 먹어요!");
}
```

