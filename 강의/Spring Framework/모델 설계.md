#Java 
#Spring 

---
# DTO, VO, DAO
DTO : 여러 개의 데이터를 묶어 하나의 단위 객체로 구성하기 위해 주로 사용
	최소한의 규칙
	- 생성자가 없거나 반드시 파라미터가 없는 생성자 함수를 가지는 형태
	- 멤버 변수는 반드시 private
	- getter/setter 제공

VO : 데이터 자체 원본 형태로 저장하거나 불러오기 위해 사용
	- 보통은 읽기 전용으로 getter만 제공

DAO : DB와의 연동을 전문적으로 처리하는 객체
	- 비즈니스 로직과 무관하도록 구성하고 DB에 원하는 작업을 처리하는 메소드들로 구성
	- 파라미터나 리턴타입은 DTO 또는 VO
# Web MVC 패턴 적용
### 원칙
- 브라우저의 모든 호출은 반드시 컨트롤러를 향한다.
	: 서블릿은 내부적으로 화면을 결정하므로 나중에 URL이 변경될 일이 없다는 장점
	: 컨트롤러가 많이 만들어질 수 있다
- JSP는 컨트롤러를 통해서만 호출되며, 컨트롤러에서 만들어진 데이터(Model)를 보여주는 용도

### PRG 패턴 구현

사용자가 해당 페이지(jsp)를 읽을 때 -> GET 방식
사용자가 폼을 제출했을 때 -> POST 방식

여기서 새로고침하면 -> POST 방식 한번 더
여기서 뒤로가기하면 -> GET 방식 한번 더
	=> 중복 입력 가능성 있으므로 리디렉션 필요

**doGet 부분에는 getRequestDispatcher + forward 처리**
`RequestDispatcher rd = req.getRequestDispatcher("/WEB-INF/todo/register.jsp").forward(req, resp)`
forward까지 꼭 해줘야 원활히 진행된다 !

**doPost 부분에는 sendRedirect 처리**
`resp.sendRedirect("/todo/list");` 

### JSP와 JSTL
EL(Expression Language)표기법 : JSP에 간단한 표현식 사용
반복문과 같은 구문 처리를 위해 JSTL(Java Standard Tag Library) 사용

1. 페이지 상단 JSTL 설정
	`<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>` : HTML태그 위에 추가
2. forEach 사용
```
<ul>  
    <c:forEach var = "dto" items="${list}">  
        <li>${dto}</li>  
    </c:forEach>  
</ul>  
    <c:forEach var = 'num' begin="1" end="10">  
        <li>${num}</li>  
    </c:forEach>
```
var : EL에서 사용될 이름
items : List, Set, Map, Enumeration, iterator 등의 컬렉션
begin : 값을 읽어올 인덱스 시작 값
end : 값을 읽어올 인덱스 끝 값

<% %>태그 안에는 Java 프로그래밍을 하면 된다
근데 막 쓰면 가독성이 좀 떨어짐 그냥 한번만 써서 코드 모아놓는 게 좋을 듯

### 구현 실습

TodoRegisterController.java
```
@WebServlet(name = "todoRegisterController", urlPatterns = "/todo/register")  
public class TodoRegisterController extends HttpServlet {  
    @Override  
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {  
        System.out.println("입력화면 구성");  
  
        RequestDispatcher rd = req.getRequestDispatcher("/WEB-INF/todo/register.jsp");  
        rd.forward(req, resp);  
    }  
  
    @Override  
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {  
        System.out.println("입력처리, 목록 페이지 이동");  
  
        resp.sendRedirect("/todo/list");  
    }  
}
```

register.jsp
```
<%@ page contentType="text/html;charset=UTF-8" language="java" %>  
<html>  
<head>  
    <title>Title</title>  
</head>  
<body>  
    <form action="/todo/register" method="post">  
        <button type="submit">글 등록 처리</button>  
    </form></body>  
</html>
```
PRG 패턴을 구현함
페이지 접근 시(todo/register) GET 요청 -> todo/register.jsp로 연결 응답
글 등록 처리 버튼 누르면 POST 요청 -> todo/list로 리디렉트 응답

**인스턴스 개수를 세서 싱글턴 구현할 때 enum 객체로 만들면 편함**

ConnectionUtil.java
```
public enum ConnectionUtil {  
    INSTANCE;  
    private HikariDataSource ds;  
  
    ConnectionUtil() {  
        HikariConfig config = new HikariConfig();  
        config.setDriverClassName("com.mysql.cj.jdbc.Driver");  
        config.setJdbcUrl("jdbc:mysql://localhost:3306/sqldb?serverTimezone=Asia/Seoul&charEncoding=UTF-8");  
        config.setUsername("root");  
        config.setPassword("mysql1234");  
        config.addDataSourceProperty("cachePrepStmts", "true");  
        config.addDataSourceProperty("prepStmtCacheSize", "250");  
        config.addDataSourceProperty("prepStmtCacheSqlLimit", "2048");  
  
        ds = new HikariDataSource(config);  
    }  
    // ConnectionUtil.INSTANCE.getConnection()으로 Connection 얻을 수 있음  
    public Connection getConnection() throws Exception {  
        return ds.getConnection();  
    }  
}
```
Connection 설정이 담긴 인스턴스는 하나만 생성해서 사용하는 싱글턴 패턴

**DAO에서 데이터 CRUD 로직 구현하기**

TodoDAO.java
```
public TodoVO selectOne(Long tno) throws Exception {  
    String sql = "select * from todo where tno = ?";  
    @Cleanup Connection conn = ConnectionUtil.INSTANCE.getConnection();  
    @Cleanup PreparedStatement pstmt = conn.prepareStatement(sql);  
    pstmt.setLong(1, tno);  
    @Cleanup ResultSet rs = pstmt.executeQuery();  
    rs.next();  
  
    TodoVO vo = TodoVO.builder()  
            .tno(rs.getLong("tno"))  
            .title(rs.getString("title"))  
            .dueDate(rs.getDate("dueDate").toLocalDate())  
            .finished(rs.getBoolean("finished"))  
            .build();  
    return vo;  
}
```
@Cleanup 어노테이션이 붙으면 해당 변수가 참조하는 자원을 자동으로 닫아준다.
Lombok에서 지원하는 기능임

TodoVO는 VO객체 -> Getter밖에 없다.
하지만 Builder 어노테이션을 제공하므로 객체 만들 때 Builder 패턴으로 만들어준다.

**테스트 작성**

ConnectionTest.java
```
@Test  
public void testHikariCP() throws Exception {  
    HikariConfig config = new HikariConfig();  
    config.setDriverClassName("com.mysql.cj.jdbc.Driver");  
    config.setJdbcUrl("jdbc:mysql://localhost:3306/member?serverTimezone=Asia/Seoul&charEncoding=UTF-8");  
    config.setUsername("계정명");  
    config.setPassword("비번");  
    HikariDataSource ds = new HikariDataSource(config);  
    Connection conn = ds.getConnection();  
  
    Assertions.assertNotNull(conn);  
    conn.close();  
}
```
HikariCP 사용하여 Connection Pool 만드는 것이 정상작동하는지에 대한 테스트.
conn이 Null이 아니면 테스트 성공

참고) 드라이버 클래스 이름 오탈자 주의,
JDBC URL 반드시 db명 뒤에 오는 serverTimezone 빼먹지 않도록 주의

기능 구현 후 단위 테스트 진행할 것


