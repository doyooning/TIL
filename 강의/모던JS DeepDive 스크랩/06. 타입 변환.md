#JS 

---
# 타입 변환

> `명시적 타입변환(explict coercion)` or `타입 캐스팅(type casting)` 은 개발자가 **의도적으로 값의 타입을 변환**하는 것

> `암묵적 타입변환(implicit coercion)` or `타입 강제 변환(type coercion)` 은 개발자의 의도와는 상관없이 표현식을 평가하는 도중에 **자바스크립트 엔진에 의해 암묵적으로 타입이 변환**되는 것

- 명시적 타입변환이나 암묵적 타입변환이 원시 값(primitive value)을 직접 변경하는 것은 아니다. → `변경 불가능한 값(immutable value)`
- 단지, 기존 원시 값을 사용해 다른 타입의 `새로운 원시 값을 생성` 하는 것


# 단축 평가 🔎

> `단축 평가(short-circuit evaluation)` : 논리 연산의 결과를 결정하는 피연산자를 `타입 변환하지 않고 그대로 반환`

- 단축 평가는 표현식을 평가하는 도중에 평가결과가 확정돈 경우 → 나머지 평가 과정을 생략한다.

|단축 평가 표현식|평가 결과|
|---|---|
|true ll anything|true|
|false ll anything|anything|
|true && anything|anything|
|false && anything|false|

### 논리 연산자를 사용한 단축 평가

> `논리곱(&&)` = 논리 연산의 결과를 결정하는 것은 `두 번째 피연산자`

```js
"Apple" && "Banana"; // Banana
```

- `논리곱(&&) 연산자` 는 두 개의 피연산자가 `모두 true로 평가될 때` → `true를 반환`
- `좌항 -> 우항으로 평가가 진행`

> `논리합(||)` = 논리 연산의 결과를 결정하는 것은 `첫 번째 피연산자`

```js
"Apple" && "Banana"; // Apple
```

- `논리합(||) 연산자` 는 두개의 피연산자 중 `하나만 true로 평가되어도` → `true를 반환`
- `좌항 -> 우항으로 평가가 진행`

```js
// 💡 논리 연산자 단축 평가 - 기본

// 논리합(||) 연산
"Cat" || "Dog"; // "Cat"
false || "Dog"; // "Dog"
"Cat" || false; // "Cat"

// 논리곱(&&) 연산
"Cat" && "Dog"; // "Dog"
false && "Dog"; // "false"
"Cat" && false; // "false"
```

```js
// 💡 논리 연산자 단축 평가 - if문 대체 -> 값 할당 시 깔끔함

var done = true;
var message = "";

// 💩 조건문으로 값 할당
if (done) message = "값";

// 👍 논리 연산자(논리곱)으로 값 할당
meessage = done && "값";
```

```js
// 💡 "객체"를 가리키기를 기대하는 변수가 null 또는 undefined 가 아닌지 확인하고 프로퍼티를 참조할 때
// 객체는 { 키 : 값 } 으로 구성된 프로퍼티(property)의 집합
// 객체를 가리키기를 기대하는 변수의 값이 객체가 아닌 null 이나 undefined 인 경우, 객체 참조시 TypeError가 발생 -> 프로그램 강제 종료

// 💩
var elem = null;
var value = elem.value; // TypeError: Cannot read property 'value' of null

// 👍
// elem이 null 또는 undefined 같은 "Falsy 값"이면 elem 값으로 평가
// elem이 "Truthy 값"이면 elem.value 로 평가
var elem = null;
var elem = elem && elem.value; // null
```

```js
// 💡 함수 매개변수에 기본값을 설정할 때
// 함수를 호출할 때 인수를 전달하지 않으면 매개변수에는 undefined 가 할당

// 💩 인수를 전달하지 않을 경우
function getStringLength(str) {
  return str.length;
}
getStringLength(); // TypeError: Cannot read property 'length' of undefined

// 👍 단축 평가를 사용한 매개변수의 기본값 설정
function getStringLength(str) {
  str = str || "";
  return str.length;
}
getStringLength(); // 0

// 👍 Es6의 매개변수 default parameter 설정
function getStringLength(str = "") {
  return str.length;
}
getStringLength(); // 0
```


### 옵셔널 체이닝 연산자

> `?.` = `옵셔널 체이닝(optional chaining) 연산자`

- 좌항의 피연산자가 `null 또는 undefined` → `undefined 반환`
- 그렇지 않은 경우 → `우항의 프로퍼티를 참조`

```js
var elem = null;
var value = elem?.value; // undefined
```

- 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 안전하게 참조할 때 유용
- 옵셔널 체이닝 도입 이전에는
    - `논리곱(&&)을 사용한 단축 평가`를 통해 → 변수가 null 또는 undefined 인지 확인했음

```js
var elem = null;
var value = elem && elem.value; // null (elem의 null)
```

```js
// 💡 논리곱(&&) 연산자 vs 옵셔널 체이닝 연산자

// 💩 논리곱(&&) 연산자 = 좌항 피연산자가 Falsy값이면, 좌항 피연산자를 그대로 반환한다. (단, 0 또는 ''은 객체로 평가될 때도 있다.)
var str = ""; //
var length = str && str.length; // ''

// 👍 옵셔널 체이닝 = 좌항 피연산자가 Falsy값이라도 null 또는 undefined 만 아니면, 우항의 프로퍼티를 참조한다.
var str = "";
var length = str?.length; // 0
```


### null 병합 연산자

> `??` = `병합 연산자(nullish coalescing) 연산자`

- 좌항의 피연산자가 `null 또는 undefined` → `우항의 피연산자를 반환`
- 그렇지 않은 경우 → `좌항의 프로퍼티를 참조`

```js
var foo = null ?? "default string"; // "default string"
```

- `변수에 기본값을 설정할 때 유용 !`
- null 병합 연산자 도입 이전에는
    - `논리합(||)을 사용한 단축 평가` 를 통해 → 변수에 기본값을 설정했음

```js
// 💡 논리합(||) 연산자 vs null 병합 연산자

// 💩 논리합(||) 연산자 = 좌항의 피연산자가 Falsy값이면, 우항의 피연산자를 반환 (단, 0 이나 ''은 기본값으로서 유호하다면 예기치 않은 동작이 발생 !)
var foo = "" || "default string"; // "default string"

// 👍 null 병합 연산자 = 좌항의 피연산자가 Falsy값이라도 null 또는 undefined 가 아니면, 좌항의 피연산자를 그대로 반환한다.
var foo = "" ?? "default string"; // ''
```
