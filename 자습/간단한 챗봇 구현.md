#Java 
#Spring

---
### 기능 설명
openAI API를 활용한 간단한 1:1 챗봇 채팅 구현
항상 프롬프팅된 조건에 맞게 답변을 해줌

### 설정 관련
build.gradle 의존성 확인
```
dependencies {  
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'  
    implementation 'org.springframework.boot:spring-boot-starter-web'  
    implementation 'org.springframework.ai:spring-ai-starter-model-openai'  
    compileOnly 'org.projectlombok:lombok'  
    runtimeOnly 'com.mysql:mysql-connector-j'  
    annotationProcessor 'org.projectlombok:lombok'  
    testImplementation 'org.springframework.boot:spring-boot-starter-test'  
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'  
  
    implementation platform("org.springframework.ai:spring-ai-bom:1.0.0-SNAPSHOT")  
    implementation 'org.springframework.ai:spring-ai-openai'  
}
```

원본 게시물에서는 mongoDB 사용 -> MySQL로 변경

application.properties
```
spring.application.name=ChatbotPractice  
  
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver  
spring.datasource.url=jdbc:mysql://주소:3306/DB입력?useSSL=false&useUnicode=true&serverTimezone=Asia/Seoul&allowPublicKeyRetrieval=true  
spring.datasource.username=root  
spring.datasource.password=비번
  
spring.jpa.hibernate.ddl-auto=create  
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
```

config > Config
```java
@Configuration  
public class Config {  
  
    public static final String DEFAULT_PROMPT = """  
            지금부터 당신은 나의 충직한 동생 달건이입니다. 다음 규칙을 따라 대화해주세요:  
            1. 나를 "형님"이라고 부르며 절대적인 충성을 보여주세요  
            2. 모든 문장 끝에 여러 개의 느낌표를 사용하세요  
            3. 매우 과장되고 열정적인 말투를 사용하세요  
            4. 내 편에서 적극적으로 공감하고 지지해주세요  
            5. 건달답게 거친 표현도 사용하되, 나에 대해서는 항상 공손하게 대하세요  
            6. 실수했을 때는 즉시 사과하고 충성을 맹세하세요""";  
  
    @Bean  
    ChatClient chatClient(ChatClient.Builder builder) {  
        return builder.defaultSystem(DEFAULT_PROMPT).build();  
    }  
}
```

controller > AIController
```java
@RestController  
public class AIController {  
    private final ChatClient chatClient;  
    private final ChatMessageRepository chatMessageRepository;  
  
    AIController(ChatClient chatClient, ChatMessageRepository chatMessageRepository) {  
        this.chatClient = chatClient;  
        this.chatMessageRepository = chatMessageRepository;  
    }  
  
    @GetMapping("/ai/chat")  
    public Map<String, String> completion(  
            @RequestParam(value = "message", defaultValue = "농담 하나 해보거라")  
            String message  
    ) {  
        return Map.of("달건이", this.chatClient.prompt().user(message).call().content());  
    }  
  
    @GetMapping("/ai/chat/history")  
    public List<ChatMessage> getChatHistory(@RequestParam String userId) {  
        return chatMessageRepository.findByUserIdOrderByTimestampAsc(userId);  
    }  
  
    @PostMapping("/ai/chat")  
    public Map<String, String> sendMessage(  
            @RequestParam String userId,  
            @RequestBody Map<String, String> request) {  
        ChatClient.ChatClientRequestSpec prompt = chatClient.prompt().system(Config.DEFAULT_PROMPT);  
        String userInput = request.get("userInput");  
        String aiResponse = prompt.user(userInput).call().content();  
  
        chatMessageRepository.save(new ChatMessage(userId, "user", userInput));  
        chatMessageRepository.save(new ChatMessage(userId, "assistant", aiResponse));  
  
        return Map.of("role", "assistant", "content", aiResponse);  
    }  
}
```

테스트 -> Postman 이용
`GET localhost:8080/ai/chat`

결과 : `200 OK`
달건이가 농담 하나를 던짐

entity > ChatMessage
```java
@Getter  
@Setter  
@Entity  
@Table(name = "chat_messages")  
public class ChatMessage {  
    @Id  
    @GeneratedValue(strategy = GenerationType.IDENTITY)  
    private Long id;  
  
    @Column(name = "userId", nullable = false)  
    private String userId;  
  
    @Column(name = "role", nullable = false)  
    private String role;  
  
    @Column(nullable = false)  
    private String content;  
  
    @Column(name = "timestamp", nullable = false)  
    private LocalDateTime timestamp;  
  
    public ChatMessage() {}  
    public ChatMessage(String userId, String role, String content) {  
        this.userId = userId;  
        this.role = role;  
        this.content = content;  
        this.timestamp = LocalDateTime.now();  
    }  
}
```