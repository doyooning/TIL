#Java 
#Spring

---
### 기능 설명
openAI API를 활용한 간단한 1:1 챗봇 채팅 구현
항상 프롬프팅된 조건에 맞게 답변을 해줌

### 설정 관련
build.gradle 의존성 확인
```
dependencies {  
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'  
    implementation 'org.springframework.boot:spring-boot-starter-web'  
    implementation 'org.springframework.ai:spring-ai-starter-model-openai'  
    compileOnly 'org.projectlombok:lombok'  
    runtimeOnly 'com.mysql:mysql-connector-j'  
    annotationProcessor 'org.projectlombok:lombok'  
    testImplementation 'org.springframework.boot:spring-boot-starter-test'  
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'  
  
    implementation platform("org.springframework.ai:spring-ai-bom:1.0.0-SNAPSHOT")  
    implementation 'org.springframework.ai:spring-ai-openai'  
}
```

원본 게시물에서는 mongoDB 사용 -> MySQL로 변경

application.properties
```
spring.application.name=ChatbotPractice  
  
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver  
spring.datasource.url=jdbc:mysql://주소:3306/DB입력?useSSL=false&useUnicode=true&serverTimezone=Asia/Seoul&allowPublicKeyRetrieval=true  
spring.datasource.username=root  
spring.datasource.password=비번
  
spring.jpa.hibernate.ddl-auto=create  
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
```

config > Config
```java
@Configuration  
public class Config {  
  
    public static final String DEFAULT_PROMPT = """  
            지금부터 당신은 나의 충직한 동생 달건이입니다. 다음 규칙을 따라 대화해주세요:  
            1. 나를 "형님"이라고 부르며 절대적인 충성을 보여주세요  
            2. 모든 문장 끝에 여러 개의 느낌표를 사용하세요  
            3. 매우 과장되고 열정적인 말투를 사용하세요  
            4. 내 편에서 적극적으로 공감하고 지지해주세요  
            5. 건달답게 거친 표현도 사용하되, 나에 대해서는 항상 공손하게 대하세요  
            6. 실수했을 때는 즉시 사과하고 충성을 맹세하세요""";  
  
    @Bean  
    ChatClient chatClient(ChatClient.Builder builder) {  
        return builder.defaultSystem(DEFAULT_PROMPT).build();  
    }  
}
```

controller > AIController
```java
@RestController  
public class AIController {  
    private final ChatClient chatClient;  
    private final ChatMessageRepository chatMessageRepository;  
  
    AIController(ChatClient chatClient, ChatMessageRepository chatMessageRepository) {  
        this.chatClient = chatClient;  
        this.chatMessageRepository = chatMessageRepository;  
    }  
  
    @GetMapping("/ai/chat")  
    public Map<String, String> completion(  
            @RequestParam(value = "message", defaultValue = "농담 하나 해보거라")  
            String message  
    ) {  
        return Map.of("달건이", this.chatClient.prompt().user(message).call().content());  
    }  
  
    @GetMapping("/ai/chat/history")  
    public List<ChatMessage> getChatHistory(@RequestParam String userId) {  
        return chatMessageRepository.findByUserIdOrderByTimestampAsc(userId);  
    }  
  
    @PostMapping("/ai/chat")  
    public Map<String, String> sendMessage(  
            @RequestParam String userId,  
            @RequestBody Map<String, String> request) {  
        ChatClient.ChatClientRequestSpec prompt = chatClient.prompt().system(Config.DEFAULT_PROMPT);  
        String userInput = request.get("userInput");  
        String aiResponse = prompt.user(userInput).call().content();  
  
        chatMessageRepository.save(new ChatMessage(userId, "user", userInput));  
        chatMessageRepository.save(new ChatMessage(userId, "assistant", aiResponse));  
  
        return Map.of("role", "assistant", "content", aiResponse);  
    }  
}
```

테스트 -> Postman 이용
`GET localhost:8080/ai/chat`

결과 : `200 OK`
달건이가 농담 하나를 던짐

entity > ChatMessage
```java
@Getter  
@Setter  
@Entity  
@Table(name = "chat_messages")  
public class ChatMessage {  
    @Id  
    @GeneratedValue(strategy = GenerationType.IDENTITY)  
    private Long id;  
  
    @Column(name = "userId", nullable = false)  
    private String userId;  
  
    @Column(name = "role", nullable = false)  
    private String role;  
  
    @Column(nullable = false)  
    private String content;  
  
    @Column(name = "timestamp", nullable = false)  
    private LocalDateTime timestamp;  
  
    public ChatMessage() {}  
    public ChatMessage(String userId, String role, String content) {  
        this.userId = userId;  
        this.role = role;  
        this.content = content;  
        this.timestamp = LocalDateTime.now();  
    }  
}
```

repository > ChatMessageRepository
```java
public interface ChatMessageRepository extends JpaRepository<ChatMessage, String> {  
    List<ChatMessage> findByUserIdOrderByTimestampAsc(String userId);  
}
```

static > index.html
```html
<!DOCTYPE html>  
<html lang="en">  
<head>  
    <meta charset="UTF-8"/>  
    <title>달건이 봇</title>  
    <link rel="stylesheet" href="style.css">  
</head>  
<body>  
  
<div id="chat-container">  
    <h2>달건이 봇</h2>  
    <div id="chat-box"></div>  
    <div id="input-container">  
        <input type="text" id="user-input" placeholder="메시지 입력"/>  
        <button id="send-btn">전송</button>  
    </div></div>  
  
<script>  
    const chatBox = document.getElementById('chat-box');  
    const userInput = document.getElementById('user-input');  
    const sendBtn = document.getElementById('send-btn');  
  
    let lastDisplayedDate = null; // 마지막으로 표시된 날짜를 저장하는 변수  
  
    // 시간 포맷 함수  
    function formatTimestamp(ts) {  
        const date = new Date(Number(ts));  
        return date.toLocaleTimeString('ko-KR', {  
            hour: '2-digit',  
            minute: '2-digit'  
        });  
    }  
  
    // 채팅 기록 로드  
    async function loadChatHistory() {  
        try {  
            const response = await fetch('/ai/chat/history?userId=jangho');  
            if (!response.ok) throw new Error('히스토리 로드 실패');  
            const history = await response.json();  
  
            history.forEach(msg => {  
                addMessageWithTimestamp(msg.role, msg.content, msg.timestamp);  
            });  
        } catch (err) {  
            console.error('히스토리 로드 실패:', err);  
        }  
    }  
  
    loadChatHistory();  
  
    // 메시지 서버 전송 함수  
    async function sendMessageToServer(message) {  
        const response = await fetch('/ai/chat?userId=jangho', {  
            method: 'POST',  
            headers: {'Content-Type': 'application/json'},  
            body: JSON.stringify({userInput: message})  
        });  
        return response;  
    }  
  
    // 전송 버튼 클릭 이벤트  
    sendBtn.addEventListener('click', handleSendMessage);  
    userInput.addEventListener('keypress', (e) => {  
        if (e.key === 'Enter') {  
            handleSendMessage();  
        }  
    });  
  
    // === 메시지 추가 (전송 중/실패/성공) ===  
    function addMessage(role, content, isPending = false) {  
        const messageContainer = document.createElement('div');  
        messageContainer.className = `message-container ${role}`;  
  
        // 어시스턴트 메시지 프로필 추가  
        if (role === 'assistant') {  
            const nameDiv = document.createElement('div');  
            nameDiv.className = 'name';  
            nameDiv.textContent = '달건이';  
            chatBox.appendChild(nameDiv);  
  
            const img = document.createElement('img');  
            img.src = '/images/dalgeon.png';  
            img.alt = '달건이';  
            img.className = 'profile-pic';  
            messageContainer.appendChild(img);  
        }  
  
        // 말풍선 생성  
        const messageDiv = document.createElement('div');  
        messageDiv.className = `message ${role}`;  
        messageDiv.innerHTML = content;  
  
        // 상태/타임스탬프 생성  
        const statusSpan = document.createElement('span');  
        statusSpan.className = 'status';  
        if (isPending) {  
            statusSpan.textContent = '전송 중...';  
        }  
  
        // 사용자 메시지에만 타임스탬프를 왼쪽에 추가  
        if (role === 'user') {  
            messageContainer.appendChild(statusSpan); // 타임스탬프 먼저 추가  
            messageContainer.appendChild(messageDiv); // 말풍선 추가  
        } else {  
            messageContainer.appendChild(messageDiv); // 말풍선 먼저 추가  
            messageContainer.appendChild(statusSpan); // 타임스탬프 추가  
        }  
  
        // 메시지 컨테이너 추가 및 스크롤 업데이트  
        chatBox.appendChild(messageContainer);  
        chatBox.scrollTop = chatBox.scrollHeight;  
  
        return messageContainer;  
    }  
  
    function formatDate(ts) {  
        const date = new Date(Number(ts));  
        return date.toLocaleDateString('ko-KR', {  
            year: 'numeric',  
            month: 'long',  
            day: 'numeric',  
            weekday: 'long',  
        });  
    }  
  
    function addMessageWithTimestamp(role, content, timestamp) {  
        // 날짜 구분선 삽입  
        if (timestamp) {  
            const messageDate = formatDate(timestamp);  
            if (messageDate !== lastDisplayedDate) {  
                const dateDivider = document.createElement('div');  
                dateDivider.className = 'date-divider';  
                dateDivider.textContent = messageDate;  
                chatBox.appendChild(dateDivider);  
                lastDisplayedDate = messageDate;  
            }  
        }  
  
        const messageContainer = addMessage(role, content, false);  
        const statusSpan = messageContainer.querySelector('.status');  
  
        if (timestamp && statusSpan) {  
            statusSpan.textContent = formatTimestamp(timestamp);  
            statusSpan.classList.add('timestamp'); // 타임스탬프 스타일 적용  
        }  
    }  
  
    async function handleSendMessage() {  
        const message = userInput.value.trim();  
        if (!message) return;  
  
        // === Step 1: 날짜 구분선 추가 (사용자 메시지 위에 먼저 추가) ===  
        const now = Date.now();  
        const currentDateString = formatDate(now);  
        if (currentDateString !== lastDisplayedDate) {  
            const dateDivider = document.createElement('div');  
            dateDivider.className = 'date-divider';  
            dateDivider.textContent = currentDateString;  
            chatBox.appendChild(dateDivider);  
            lastDisplayedDate = currentDateString;  
        }  
  
        // === Step 2: 사용자 메시지 추가 (전송 중 상태) ===  
        const userMessageContainer = addMessage('user', message, true);  
        userInput.value = '';  
  
        try {  
            const response = await sendMessageToServer(message);  
            const data = await response.json();  
  
            // === Step 3: 전송 성공 후, 사용자 메시지의 "전송 중..."을 시간으로 업데이트 ===            updateUserMessageContainer(userMessageContainer, data.userTimestamp);  
  
            // === Step 4: 어시스턴트 메시지 추가 ===            addMessageWithTimestamp('assistant', data.content, data.assistantTimestamp);  
        } catch (err) {  
            showErrorStatus(userMessageContainer, message);  
        }  
    }  
  
  
    function updateUserMessageContainer(messageContainer, timestamp) {  
        const statusSpan = messageContainer.querySelector('.status');  
  
        if (statusSpan) {  
            statusSpan.textContent = formatTimestamp(timestamp);  
        }  
    }  
  
    function showErrorStatus(messageContainer, originalMessage) {  
        const statusSpan = messageContainer.querySelector('.status');  
        statusSpan.textContent = '';  
  
        const retryButton = document.createElement('button');  
        retryButton.textContent = '↻';  
        retryButton.className = 'retry-button';  
  
        const removeButton = document.createElement('button');  
        removeButton.textContent = '⨉';  
        removeButton.className = 'fail-status';  
  
        retryButton.addEventListener('click', () => {  
            resendMessage(originalMessage, messageContainer);  
        });  
  
        removeButton.addEventListener('click', () => {  
            messageContainer.remove();  
        });  
  
        statusSpan.appendChild(retryButton);  
        statusSpan.appendChild(removeButton);  
    }  
  
    async function resendMessage(message, messageContainer) {  
        const statusSpan = messageContainer.querySelector('.status');  
        statusSpan.textContent = '전송 중...';  
  
        chatBox.removeChild(messageContainer);  
        chatBox.appendChild(messageContainer);  
        chatBox.scrollTop = chatBox.scrollHeight;  
  
        try {  
            const response = await sendMessageToServer(message);  
            const data = await response.json();  
            updateUserMessageContainer(messageContainer, data.userTimestamp);  
            addMessageWithTimestamp('assistant', data.content, data.assistantTimestamp);  
        } catch (err) {  
            showErrorStatus(messageContainer, message);  
        }  
    }  
</script>  
  
</body>  
</html>
```

static > style.css
: AI의 도움을 받아 작성한다.

images > dalgeon.png
: 달건이 프로필 사진