#Spring 
#Docker
#Vue3 

---
### 이론 설명

###### HTTP 요청과 웹소켓의 서버와의 연결방식 비교
![[화면 캡처 2025-12-10 212104.jpg]]
**HTTP**는 기본적으로 비연결형 프로토콜로, 클라이언트가 매번 서버에 요 청을 보내 새롭게 TCP 연결을 시도하며, 요청 처리 후 연결을 끊음  
	매번 요청을 통해 연결을 맺고 끊어야 하고, 그때마다 http메시지를 보 내야 하므로 지속적 통신에 있어서 성능저하 발생 

**웹소켓**은 연결형 프로토콜로, 최초 1번만 연결이 성공적으로 이루어지면 WebSocket 프로토콜로 업그레이드하여 TCP 연결 유지
	한번만 연결을 맺고 나면 그 뒤엔 별도의 http메시지 없이 통신이 가능 해서 빠른 성능 보장 
	웹소켓도 최초 한번의 연결시 HTTP 헤더를 통해 token과 같은 인증 정보를 보낼수 있고, 이때에 이를 통해 인증처리를 할수 있음

###### Polling방식과 websocket 방식의 비교
![[화면 캡처 2025-12-10 212125.jpg]]
**Polling** 
클라이언트가 서버에 주기적으로 요청을 보내 업데이트를 확인하는 방식 
HTTP 요청만 처리하면 되므로 추가 설정이 필요없는 간결함 
다만, 지속적인 서버 request로 서버 과부하 가능성 존재 

**WebSocket** 
클라이언트와 서버 간 지속적인 연결을 유지 
무거운 HTTP 메시지가 필요 없이 직접 메시지를 주고 받음으로서 서버 부하 측면에서 우수

###### SSE기술과 Websocket 비교
![[화면 캡처 2025-12-10 212141.jpg]]
**SSE(Server-Sent Events)**
HTTP기반의 클라이언트와 서버 간의 실시간 단방향 통신을 가능하게 하는 웹 기술 

웹소켓과의 차이 
	sse프로토콜을 사용한 통신방향이 서버 → 프론트엔드로의 단방향 통신
	프론트에서 서버로의 데이터 전송은 일반적인 HTTP통신 

서버는 클라이언트에게 지속적으로 데이터를 전송할 수 있으며, 주로 실시간 업데이트가 필요한 애플리케이션에서 사용(특히, 사용자에게 알림을 주기 위한 목적으로 많이 활용)

**STOMP(Simple Text Oriented Messaging Protocol)**
WebSocket 위에서 동작하는 메시징 프로토콜 

일반 웹소켓
![[화면 캡처 2025-12-10 212702.jpg]]

STOMP
![[화면 캡처 2025-12-10 212722.jpg]]
Stomp는 websocket과 다르게, 목적지기반 메시지 라우팅 지원 
	클라이언트와 서버가 특정 주제(topic) 또는 경로를 기준으로 메시지를 교환하는 구조 

메시지 교환 절차 
	클라이언트에서 지정된 특정 roomId에 메시지를 발행하면 broker에 의해서 해당 roomId 채널에 메시지가 전달 
	동시에 roomId를 구독하고 있는 클라이언트에게 실시간으로 메시지가 전달

###### redis pub/sub을 통해 멀티서버 환경 고려
![[화면 캡처 2025-12-10 213027.jpg]]
웹소켓 통신에서 특정 사용자는 특정 서버의 메모리에 의존적이어서, 클라이언트A가 발행한 메시지를 클라이언트B는 다른 서버에 연결되어 받지 못할 수 있음
이러한 멀티 서버 환경에서 원활한 채팅을 위해서 메시지를 서버에 모두 전파해 주는 **redis pub/sub기능** 사용

==메시지 발행, 구독 절차==
	클라이언트는 송신할 메시지를 websocket server에 송신 
	websocket server는 해당 메시지를 곧바로 특정 topic에 메시지를 발행하지 않고, redis의 pub/sub 기능을 활용하여 메시지를 모든 서버에 publish 
	모든 서버는 redis를 subscribe하고 있기에 redis로부터 발행된 message를 받아서, 본인 서버의 topic에 메시지를 발행 
	각 서버를 subscribe하고 있는 클라이언트들은 특정 room에 전파된 message를 수신



