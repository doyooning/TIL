#Java 
#Spring 
#SpringSecurity 
#JWT

---
https://cafe.naver.com/xxxjjhhh/94
개발자 유미 강의 참조

https://spring.io/guides/gs/securing-web
스프링 시큐리티 공식 문서 가이드


### 토큰 사용 추적

단일 토큰(Access Token)의 사용처 추적:

1. 로그인 성공 JWT 발급 : 서버측 → 클라이언트로 JWT 발급
2. 권한이 필요한 모든 요청 : 클라이언트 → 서버측 JWT 전송

권한이 필요한 요청은 서비스에서 많이 발생 (회원 CRUD, 게시글/댓글 CRUD, 주문 서비스, 등등)

따라서 JWT는 매시간 수많은 요청을 위해 클라이언트의 JS 코드로 HTTP 통신을 통해 서버로 전달됨

해커는 클라이언트 측에서 XSS를 이용하거나 HTTP 통신을 가로채서 토큰을 훔칠 수 있기 때문에 여러 기술을 도입하여 탈취를 방지하고 탈취되었을 경우 대비 로직이 존재


### 다중 토큰 : Refresh 토큰과 생명 주기

위와 같은 문제가 발생하지 않도록  **Access/Refresh 토큰** 개념이 등장

자주 사용되는 토큰의 생명주기는 짧게(약 10분), 
이 토큰이 만료되었을 때 함께 받은 Refresh 토큰(24시간 이상)으로 토큰을 재발급

(생명주기가 짧으면 만료시 매번 로그인을 진행하는 문제가 발생, 생명주기가 긴 Refresh도 함께 발급함)


**1. 로그인 성공시 생명주기와 활용도가 다른 토큰 2개 발급 : Access/Refresh**

Access 토큰
: 권한이 필요한 모든 요청 헤더에 사용될 JWT로 탈취 위험을 낮추기 위해 약 10분 정도의 짧은 생명주기를 가짐

Refresh 토큰
: Access 토큰이 만료되었을 때 재발급 받기 위한 용도로만 사용되며 약 24시간 이상의 긴 생명주기를 가짐

**2. 권한이 필요한 모든 요청 : Access 토큰을 통해 요청**

Access 토큰만 사용하여 요청하기 때문에 Refresh 토큰은 호출 및 전송을 빈도가 낮음

**3. 권한이 알맞다는 가정하에 2가지 상황 : 데이터 응답, 토큰 만료 응답**

**4. 토큰이 만료된 경우 Refresh 토큰으로 Access 토큰 발급**

Access 토큰이 만료되었다는 요청이 돌아왔을 경우, 
프론트엔드 로직에 의해 “1”에서 발급 받은 Refresh 토큰을 가지고 서버의 특정 경로(Refresh 토큰을 받는 경로)에 요청을 보내어 Access 토큰을 재발급 받음

**5. 서버측에서는 Refresh 토큰을 검증 후 Access 토큰을 새로 발급함**

### 다중 토큰 구현 포인트

- 로그인이 완료되면 `successHandler`에서 Access/Refresh 토큰 2개를 발급해 응답
	각 토큰은 각기 다른 생명주기, payload 정보를 가짐

- Access 토큰 요청을 검증하는 `JWTFilter`에서 Access 토큰이 만료된 경우는 프론트 개발자와 협의된 상태 코드와 메시지를 응답

- 프론트측 API 클라이언트 (axios, fetch) 요청시 Access 토큰 만료 요청이 오면 예외문을 통해 Refresh 토큰을 서버측으로 전송하고 Access 토큰을 발급 받는 로직을 수행 (기존 Access는 제거)

- 서버측에서는 Refresh 토큰을 받을 엔드포인트 (컨트롤러)를 구성하여 Refresh를 검증하고 Access 응답

